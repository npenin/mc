{
  "name": "hdhomerun",
  "version": "0.0.3",
  "description": "low-level control of HDHomeRun TV tuner devices",
  "main": "index.js",
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "bugs": {
    "url": "http://github.com/mharsch/node-hdhomerun/issues"
  },
  "dependencies": {
    "buffer-crc32": ">=0.2.1"
  },
  "engines": {
    "node": ">=0.9.4"
  },
  "devDependencies": {
    "nodeunit": ">=0.7.4"
  },
  "scripts": {
    "test": "nodeunit ./test/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mharsch/node-hdhomerun.git"
  },
  "keywords": [
    "hdhomerun",
    "tv",
    "tuner",
    "video",
    "dvr"
  ],
  "author": {
    "name": "Michael Harsch",
    "email": "mike@harschsystems.com"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "readme": "#hdhomerun\n\nControl your [SiliconDust](http://www.silicondust.com) HDHomeRun network-attached digital TV tuner from node.js.  This module provides a JavaScript interface to discover devices, and to get and set device control variables.  While not a complete solution in itself, hdhomerun provides the low-level functionality necessary to build higher level tools and applications (such as DVR).  Users of hdhomerun will certainly want to refer to [libhdhomerun](http://github.com/mharsch/libhdhomerun) (the C library provided by the manufacturer) for details on how the low-level get/set API can be used to implement higher-level functionality.  See [examples/cli.js](examples/cli.js) for a node version of the libhdhomerun 'hdhomerun\\_config' CLI utility.  \n\n##Installation:\n\n\tnpm install hdhomerun\n\n##Usage:\n\nUse the discover() method to find devices on the local network:\n```javascript\nvar hdhr = require('hdhomerun');\n\nhdhr.discover(function (err, res) {\n\tconsole.log(res);\n};\n> [ { device_id: '1038A145',\ndevice_type: 'tuner',\ntuner_count: 2,\ndevice_ip: '192.168.2.123' } ]\n```\n\nNow create a device object:\n```javascript\nvar device = hdhr.create({device_id: '1038A145',\n    device_ip: '192.168.2.123'});\n```\n\nUsing the device object, you can get and set named control variables:\n```javascript\ndevice.get('/sys/model', function (err, res) {\n\tconsole.log(res);\n}\n> { name: '/sys/model', value: 'hdhomerun3_atsc' }\n```\n\nControl variables are used to interact with the device.  Most importantly, they let you change channels and initiate a video stream:\n```javascript\ndevice.set('/tuner0/channel', 'auto:9', function (err, res) {\n\tconsole.log(res);\n}\n> { name: '/tuner0/channel', value: 'auto:9' }\n\ndevice.get('/tuner0/streaminfo', ...\n> 1: 9.1 KUSA-DT\n> 2: 9.2 9News N\n> tsid=0x01CF\n\ndevice.set('/tuner0/program', 1, ...\ndevice.get('/tuner0/status', ...\n> value: 'ch=auto:9 lock=8vsb ss=92 snq=77 seq=100 bps=19394080 pps=0'\n\ndevice.set('/tuner0/target', 'udp://localhost:54321', ...\n> // Now MPEG2 data is streaming to the specified host/port\n```\n\n##API:\n\n### discover([search\\_id], callback)\n* `search_id` {String} Optional device\\_id of device we wish to discover\n* `callback` {Function} Callback function\n    * `err` {Error Object} not yet implemented\n    * `found` {Array} Array of discovered device objects\nThe `found` array contains objects representing discovered devices.  Each\nobject contains the following fields:\n        * `device_id` {String}\n        * `device_type` {String} Will always be 'tuner'\n        * `tuner_count` {Number} number of tuners in the device\n        * `device_ip` {String} IP address of the device\n\nWhen called without a `search_id` argument, discover() will accept responses from all devices on the local network that respond to it's broadcast request within the timeout period (currently 500ms).  \n\nIf `search_id` is specified, only a matching device will respond to the broadcast.  Once a matching response is received, callback() is immediately called.\n\n### create(conf)\n* `conf` {Object}\n    * `device_id` {String}\n    * `device_ip` {String}\n* Returns: {Object} new Device object\n\n### Class: Device\nDevice objects maintain a TCP connection with their corresponding physical device.  This control socket is used to send get/set messages and receive responses.  Device instances initiate the control socket connection immediately and emit `connected` when the connection is ready.  \n\n### Device.get(variable, callback)\n* `variable` {String} named control variable to retrieve\n* `callback` {Function} called when a response from the device arrives\n    * `err` {Error Object}\n    * `res` {Object} response object with the following members:\n        * `name` {String} the requested control variable\n        * `value` {String} the value of the requested variable\n\n### Device.set(variable, value, callback)\n* `variable` {String} named control variable to set\n* `value` {String} value to set the control variable\n* `callback` {Function} called when a response from the device arrives\n    * `err` {Error Object}\n    * `res` {Object} response object with the following members:\n        * `name` {String} the requested control variable\n        * `value` {String} the (updated) value of the requested variable\n\n##Examples:\n\n[examples/cli.js](examples/cli.js) implements (roughly) the same functionality as [libhdhomerun](http://github.com/mharsch/libhdhomerun) 'hdhomerun\\_config'.  This toy program demonstrates how one could implement common functionality such as channel scanning and saving video streams (in a node-y way).  \n\n##Testing:\n\nCurrently, an actual HDHomeRun device is required to execute the tests.  Set an environment variable 'MY\\_HDHR' to the device\\_id (aka serial #) of your local device before running 'npm test'.  \n\n##Supported Devices\n\n* HDHR3-US (Dual Tuner ATSC)\n\n##TODO:\n\n* proper tests\n* additional device support\n* more complete and standardized error handling\n\n##License:\nMIT.\n",
  "_id": "hdhomerun@0.0.3",
  "dist": {
    "shasum": "21fdbb38dd3f18536677068ed83ec3e8f7b0a0fa"
  },
  "_from": "hdhomerun@",
  "_resolved": "https://registry.npmjs.org/hdhomerun/-/hdhomerun-0.0.3.tgz"
}
